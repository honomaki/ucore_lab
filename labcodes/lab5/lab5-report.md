# 实验五：用户进程管理
<br/>
## 练习1: 加载应用程序并执行

根据注释，把tf的各个成员变量设置好
* 请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过
  
  设置用户堆栈，建立虚拟地址与物理地址的映射，建立页表。修改trapframe，即这一步中的tf,tf相应的值被设置成了用户态的值，这样在iret指令返回之后就会成为用户态的进程进行执行

## 练习2: 父进程复制自己的内存空间给子进程
按照注释，使用 page2kva 得到需要进行拷贝的地址 src 和 des ，通过 memcpy 对其进行复制，再用 page_insert 建立物理页与虚拟页的映射

* 请在实验报告中简要说明如何设计实现 Copy on Write 机制，给出概要设计

  在父进程创建子进程时，进行拷贝时直接拷贝页的地址指针，但把空间设置为只读。当进行写操作时会产生一个页异常中断，这时进行拷贝工作即可

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

 fork/exec/wait/exit函数分别对应了系统调用SYS_fork、SYS_exec、SYS_wait、 SYS_exit；系统调用实现是通过产生特定中断，在syscall函数中调用该中断trapframe中保存的eax值所对应的syscalls中的函数指针

* 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的?

  fork可以产生拷贝自己的子进程；exec使用load_icode复制执行进程；wait使当前进程进入子进程或者IO操作的状态；exit可以回收当前进程资源，并进入僵尸模式等待父进程回收

* 请给出ucore中一个用户态进程的执行状态生命周期图

  进入就绪队列 -> 就绪 -> 执行 -> 就绪 -> ... -> 执行 -> 退出

  